# 数据库设计范式
### 1. 第一范式（1NF）
```
	指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。即实体中某个属性不能有多个值，或不能有重复的属性。
```
> 第一范式遵从原子性

### 2. 第二范式（2NF）
```
	基于第一范式。要求实体的属性完全依赖于主键，不能仅依赖主键的一部分（对于复合主键而言）
```
> 第二范式遵从唯一性

### 3. 第三范式（3NF）
```
	基于第二范式。要求一个数据表中每一列数据都和主键直接相关，而不能间接相关
```
> 第三范式就是非主键字段不能相互依赖





# MySQL 事务四大特性（ACID）

### 1. 原子性（Atomicity）
```
	指一个事务必须被视为一个不可分割的最小工作单元。要么事务中所有操作都执行成功，要么有一个失败，已执行的全部撤销，数据库状态退回执行事务前。
```
### 2. 一致性（Consistency）
```
	指事务处理时，无论执行成功或失败，都要保证数据库处于一致的状态，保证不会返回到一个未处理的事务中。
```
### 3. 隔离性（Isolation）
```
	指当一个事务执行时，不会受到其他事务的影响。保证了未完成事务的所有操作与数据库系统的隔离，直到事务完成才能看到结果。
```
### 4. 持久性（Durability）
```
	指事务一旦提交，其对数据库的修改就是永久性的。但此永久并非百分百，由外部原因导致数据库故障，如硬盘损坏，那么提交的数据可能都会丢失。
```



# MySQL 事务四大隔离级别
### 1. read uncommitted（读取未提交）——脏读
```
	事务中最低的级别。事务可以读取到其他事务中未提交的数据（脏读）
```
### 2. read committed（读取提交）——不可重复读
```
	只能读取其他事务已经提交的数据，避免了脏读。但会出现不可重复读的问题。
	不可重复读指一个事务中多次查询的结果不一致，原因是查询过程中数据发生了改变。
```
> 除 MySQL 外大多数 DBMS 以 read committed 作为默认隔离级
### 3. repeatable read（可重复读）
```
	解决了脏读和不可重复读的问题，确保了同一事务的多个实例在并发读取数据时，会看到同样的结果。但会出现幻读现象。
	幻读指在一个事务内两次查询中数据条数不一致。幻读和不可重复读类似，都是发生在两次查询中，但幻读是由于其他事务做了插入操作导致记录数有所增加。
```
> MySQL 默认隔离级别为 repeatable read
> MySQL 的 InnoDB 存储引擎通过多版本并发控制机制解决了幻读问题（间隙锁和版本号）
### 4. serializable（可串行化）
```
	事务中最高的级别。在每个读的数据行上加锁，使之不会冲突，解决了脏读、不可重复读和幻读问题。但由于加锁可能导致超时和锁竞争，因此 serializable 性能最低。
```



# MySQL索引
### 1. 基础知识
* MySQL 基本存储结构是页
* 各个数据页可以组成一个双向链表
* 每个数据页中的记录可以组成一个单向链表
> 每个数据页都会为存储其中的记录生成一个页目录，通过主键查找某条记录时可以再页目录中使用二分法找到对应的槽，然后遍历该槽对应分组中的记录即可快速找到指定记录。
> 以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表每条记录

**select * from user where username=xxx 查询过程：**
```
	页与页之间是双向链表，页内是单链表。需要沿着双向链表，从第一页开始，依次遍历每一页，最终找到对应数据。
```

### 2. 索引提高检索速度
```
	原理：将无序数据变成有序。在目录页基础上添加顶层目录页
```

### 3. 索引降低增删改的速度
```
	原因：B+树是平衡树的一种，对其增删改会破坏原有结构。要维持平衡树，就必须做额外的工作，因为这些额外的工作开销，导致降低增删改速度。
```

### 4. 哈希索引
```
	原理：采用哈希算法，把键值换算成新的哈希值，检索时只需一次哈希算法即可立刻定位到相应位置。
```
缺陷：
* 无法利用索引完成排序
* 不支持最左匹配原则
* 哈希碰撞问题
* 不支持范围查询

### 5. InnoDB 支持哈希索引吗？
```
	主流使用 B+树索引比较多，InnoDB自适应哈希索引（hash 索引的创建由 InnoDB 自动优化创建，干预不了）
```

### 6. 聚集和非聚集索引
* **聚集索引**：以主键创建的索引
* **非聚集索引**：以非主键创建的索引
> 区别：
> 1. 聚集索引在叶子节点存储的是表中数据
> 2. 非聚集索引在叶子节点存储的是主键和索引列
> 3. 使用非聚集索引查询时，拿到叶子上的主键再去查找想要查找的数据

非聚集索引可以是多列，此时会生成索引树（因此过多创建索引会占用磁盘空间）
> 覆盖索引：非聚集索引查询时需要“回表”，覆盖索引就是把要查询出的列和索引对应，不做回表操作
> 建立多列索引时会涉及哪个列走索引，哪个不走，这涉及遵循最左匹配原则

### 7. 索引最左匹配原则
```
	多列索引（联合索引）下，key 也由多个列组成。索引只能用于查找 key 是否存在（相等），遇到范围查询（>，<，between，like）等不能进一步匹配了，后续退化为线性查找。
	因此，列的排列顺序决定了可命中索引的列数。
```
> 例：如有索引（a，b，c，d），查询条件 a=1 and b=2 and c>3 and d=4，则会在每个结点依次命中a，b，c，无法命中 d（会一直向右匹配，知道遇到范围查询就停止匹配）

### 8. =、in 自动优化顺序
```
	不需要考虑 =、in 等的顺序，MySQL会自动优化，以匹配尽可能多的索引列。
```



# MySQL 锁
### 1. 表锁
* 从锁的粒度，分为两类：
    * 表锁：开销小，加锁快，不会死锁，锁定力度大，发生锁冲突概率高，并发度最低
    * 行锁：开销大，加锁慢，会出现死锁，锁定力度小，发生锁冲突概率低，并发度高
* InnoDB 支持行锁和表锁（自动）。且行锁基于索引。MyISAM 只支持表锁
* 表锁分为两种模式：
    * 表读锁
    * 表写锁
    * 读读不阻塞，读写阻塞，写写阻塞
* 读锁与写锁互斥，读写操作串行。写锁优先于读锁
* MyISAM 支持读写并发
    * 若 MyISAM 表中没有被删除的行（空洞），允许一个进程读表时，另一个从表尾插入数据

### 2. 行锁
> InnoDB 一大特性就是支持行锁
* 分类：
    * 共享锁（S锁）：允许一个事务读一行，阻止其他事务获得相同数据集的排它锁，也叫读锁。读锁共享，允许多用户同时读，不允许改。
    * 排他锁（X锁）：允许获得排他锁的事务更新数据，阻止其他事务取得同数据集的共享读锁和排他写锁。也叫写锁。写锁会阻塞其他的写锁和读锁。
* 为了允许行锁与表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁。均为**表锁**，且数据库隐式完成，无需操心。
    * 意向共享锁（IS）：事务打算给数据行加行共享锁前必须取得该表的 IS 锁
    * 意向排他锁（IX）：同上，为加行排他锁前获得

### 3. 从锁重新审视事务隔离级别
* 脏读：出现脏读的本质是因为操作完数据立马释放锁，导致读的数据错误
* 不可重复读：read committed 是语句级别的快照，每次读取的都是当前最新的版本
* repeatable read 是事务级别的快照，每次读取的是当前事务的版本，即使修改了，也只会读取当前事务版本的数据
> 原理（MVCC）：在每行记录后面保存两个隐藏的列，一个存行的创建时间，一个存行的删除时间。存的不是时间值而是**系统版本号**。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务版本号，用来和查询到的每行记录的版本号比较。

### 4. 悲观锁和乐观锁
解决丢失更新问题（一个事务的更新覆盖了其他事务的更新结果）
* 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次拿数据时都会上锁，别人想拿就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源让给其他线程）
> 行锁、表锁、读锁、写锁均为悲观锁，Synchronized 和 ReentrantLock 也基于悲观锁
* 乐观锁：总是假设最好的情况，每次去拿数据时都认为别人不会修改，所以不会上锁，但在更新时会判断一下在此期间别人有没有去更新这个数据，可以使用**版本号机制**和**CAS**实现。
> 乐观锁适用于多读的应用类型，这样可以提高吞吐量
> 版本号机制：MySQL使用。表中有一个版本字段，第一次读的时候获取。处理完业务开始更新时需要查看该字段值是否和第一次一样。若一样则更新，反之拒绝。

### 5. 间隙锁 GAP
```
	当我们用范围条件检索数据并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁
	对于键值在条件范围内但并不存在的记录（还未插入），叫做“间隙”，InnoDB 也会对其上锁，称为间隙锁
	GAP只会在 repeatable read 下使用
```
> 目的：防止幻读

### 6. 死锁
**降低死锁方法：**
* 以固定顺序访问表和行（先排序，后执行，避免交叉等待锁）
* 大事务拆小
* 在同一事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率
* 降低隔离级别
* 为表添加合理索引（触发行锁）

**MySQL索引为什么使用B+树而不用其他的？**
* 哈希索引：不能支持部分索引查询和范围查询
> 什么情况下可以使用 Hash 索引？
> 查询条件不会变且没有部分查询和范围查询

* 红黑树：
    * 读取磁盘次数过多
    * 读取浪费太多（16K 磁盘页只存了一个节点值）
> 为什么可以用在 HashMap 的查找？
> 因为 HashMap 是存储在内存中的

> n 叉树取代二叉树，缩短树高度，解决哈希索引的问题
> 每个结点存储多个值解决红黑树的问题
> => B 树

* B 树：存储结构为索引 + 数据
> 无法解决范围查找问题

* B+树：在B树基础上
    * 叶子结点通过双向链表相连（解决范围查找问题）
    * 非叶子结点不存数据
    * 数据和结点一样多
    * 当前结点中加入父结点当前范围的最大/最小结点
    * 最底层叶子存储联合索引。B+树只会根据 userID（第 1 个索引）构建，因此必须遵从最左匹配原则

**总结：B+树最适合大数据的磁盘索引，经典的MySQL，所有的数据都存在叶子结点，其他都是索引，增加了系统的稳定性以及遍历以及查找效率**
不同：关键字和 Key 值。数据存储位置。双向链表
M 阶：这个由磁盘的页面大小决定，磁盘块和页内存都是 4 KB。结点数（也就是 M 值）应尽可能与其一样。这样的好处是能一次刚好全部拿出一个结点里存的所有数据。