# Redis 6
## 1. NoSQL 数据库
**概述：**
* Not Only SQL，泛指非关系型数据库，以 key-value 模式存储
* 不遵循 SQL 标准
* 不支持 ACID
* 远超于 SQL 的性能

**适用场景：**
* 对数据高并发的读写
* 海量数据的读写
* 对数据高可扩展性

**不适用场景：**
* 需要事务支持
* 基于 sql 的结构化查询存储，处理复杂关系，需要即时查询



## 2. Redis 概述
* Redis 是一个开源的 key-value 存储系统
* 支持存储的 value 类型更多，包括 String、list、set、zset（sorted set）和 hash
* 数据类型都支持 push/pop、add/remove 及取交集并集和差集等操作，且都是原子性的
* 支持不同方式的排序
* 数据都是缓存在内存中
* 会周期性把更新的数据写入磁盘或者把修改操作写入追加的记录文件
* 在此基础上实现了 master-slave（主从）同步

### Redis 相关知识
* 默认端口：6379
* 默认 16 个数据库，初始默认使用 0 号库
* 使用命令 select &lt;dbid&gt; 来切换数据库，如 select 8
* 统一密码管理，所有库同样密码
* dbsize 查看当前数据库 key 的数量
* flushdb：清空当前库；flushall：通杀全部库

### Redis 是单线程 + 多路 IO 复用技术
* 多路复用是指使用一个线程来检查多个文件描述符（socket）的就绪状态，比如调用 select 和
 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一线程里执行，也可以启动线程执行（比如使用线程池）

### 与 Memcache 三点不同：
* 支持多数据类型，支持持久化，单线程 + 多路 IO 复用



## 3. 常用五大数据类型
### 3.1 Redis 键（key）
* del key：删除指定的 key 数据
* unlink key：根据 value 选择非阻塞删除
* 仅将 keys 从 keyspace 元数据中删除，真正的删除会在后续异步操作

### 3.2 Redis 字符串（String）
#### 3.2.1 简介
* String 是 Redis 最基本的类型。String 类型是二进制安全的。Redis 的 String 可以包含任何数据，比如 jpg 图片或序列化对象
* 字符串 value 最多可以是 512 M

#### 3.2.2 原子性
* 原子操作是指不会被线程调度机制打断的操作。一旦开始，就一直运行到结束，中间不会有任何 context switch（切换到另一个线程）
* 单线程中，能够在单条指令中完成的操作都可认为是原子操作，因为中断只能发生于指令之间
* 多线程中，不能被其他进程（线程）打断的操作就叫原子操作
* Redis 单命令的原子性主要得益于 Redis 单线程

#### 3.2.3 数据结构
* String 的数据结构为简单动态字符串，是可以修改的字符串，内部结构实现上类似 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配
* 最大分配空间 512 M

### 3.3 Redis 列表（List）
#### 3.3.1 简介
* 单键多值
* Redis 列表是简单的字符串列表，按插入顺序排序，可以添加一个元素到列表的头部或尾部。
* 底层实际是个双向链表，对两端的操作性能很高，通过索引下标操作中间节点性能会很差值在键在，值光键亡

#### 3.3.2 数据结构
* List 的数据结构为快速链表 quickList

* 在列表元素较少时会使用一块连续的内存存储，该结构是 zipList，即压缩列表

* 当数据量较多时会改成 quickList

* Redis 将链表和 zipList 结合组成 quickList，即将多个 zipList 使用双向指针串起来。既满足了快速插入删除性能，又不会出现太大的空间冗余

![Redis列表数据结构](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/Redis列表数据结构.7gcm4wp1tbg0.png)

### 3.4 Redis 集合（Set）
#### 3.4.1 简介
* set 功能与 List 类似，特殊之处是其可以自动排重
* set 是 String 类型的无序集合。底层是一个 value 为 null 的 hash 表，所以添加、删除，查找的复杂度都是 O(1)

#### 3.4.2 数据结构
* Set 数据结构是 dict 字典，字典是用哈希表实现的。Java 中 HashSet 内部实现使用的是 HashMap。只不过所有的 value 都指向同一个对象。Redis 的 Set 结构也一样，内部也使用 hash 结构，所有 value 指向同一个内部值

### 3.5 Redis 哈希（Hash）
#### 3.5.1 简介
* Redis hash 是一个键值对集合
* Redis hash 是一个 String 类型的 field 和 value 的映射表，hash 特别适合存储对象，类似 Java 里的 Map&lt;String, Object&gt;

#### 3.5.2 数据结构
* Hash 对应的数据结构有两种：zipList、hashtable
* 当 field-value 长度较短且个数较少时，使用 zipList，否则使用 hashtable

### 3.6 Redis 有序集合 Zset（sorted set）
#### 3.6.1 简介
* zset 与 set 相似，是没有重复元素的字符串集合
* 不同之处是有序集合的每个成员都关联了一个评分（score），评分用来按从最低分到最高分排序集合中成员。集合成员是唯一的，但评分可以重复。因为元素有序，因此可以很快根据评分或次序获取一个范围的元素
* 访问有序集合的中间元素也非常快，因此可以使用有序集合作为一个没有重复成员的智能列表

#### 3.6.2 数据结构
* zset 一方面等价于 Map&lt;String, Double&gt;，可以给每个元素 value 赋予一个权重 score，另一方面类似于 TreeSet，内部元素按权重 score 排序，可以得到每个元素名次，还可通过 score 范围获取元素列表
* zset 底层使用了两个数据结构
    - hash，作用为关联元素 value 和权重 score
    - 跳跃表，目的在于给元素 value 排序，根据 score 范围获取元素列表



## 4. Redis 的发布和订阅
### 4.1 什么是发布和订阅
* Redis 发布订阅（pub / sub）是一种消息通信模式
* 发送者（pub）发送消息，订阅者（sub）接收消息
* Redis 客户端可以订阅任意数量的频道

### 4.2 Redis 的发布和订阅
#### 4.2.1 客户端订阅频道
![Redis客户端订阅频道](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/Redis客户端订阅频道.6fhwsj7uljk0.png)

#### 4.2.2 当频道发布消息后，消息会发送给订阅的客户端
![Redis消息发送客户端](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/Redis消息发送客户端.h94kkyzuduw.png)



## 5. Redis 新数据类型
### 5.1 Bitmaps
* 可以实现对位的操作
* Bitmaps 本身不是一种数据类型，实际上它就是字符串（key-value）
* Bitmaps 单独提供了一套命令，所以在 Redis 中使用 Bitmaps 和字符串的方法不太相同。可以把 Bitmaps 想象成一个以位为单位的数组，每个单元只能存储 0 到 1，数组下标为偏移量
* 相比于 set 可以极大地节省存储空间，但若数据量较小，则 Bitmaps 不太合适，大部分位都是 0

### 5.2 HyperLogLog
* 求集合中不重复元素个数的问题称为基数问题。HyperLogLog 用来做基数统计的算法，优点是在输入元素的数量或体积非常大时，计算基数所需空间总是固定的，并且很小
* Redis 里，每个 HyperLogLog 键只花费 12 KB 内存，可计算接近 2^64 个不同元素的基数

### 5.3 Geospatial
* 对 GEO 类型的支持，即元素的二维坐标，地图上的经纬度。Redis 提供了经纬度设置，查询，范围查询，范围查询，距离查询，经纬度 Hash 等常见操作



## 6. Redis 事务和锁机制
### 6.1 Redis 的事务定义
* Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断
* Redis 事务的主要作用就是串联多个命令防止别的命令插队

### 6.2 Multi、Exec、discard
* 从输入 Multi 命令开始，输入的命令会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行
* 组队过程中可以通过 discard 来放弃组队

### 6.3 事务的错误处理
* 组队中某个命令出现了报告错误，执行时所有队列都会被取消
* 若执行阶段某个命令报出了错误，则只有报错的命令不会被执行，其他命令正常，不会回滚

### 6.4 Redis 事务冲突问题
* Redis 利用 check-and-set 机制（乐观锁）实现事务在执行 Multi 之前，先执行 watch key1[key2]，可以监视一个（或多个）key，若在事务执行之前，这些 key 被其他命令所改动，那么事务将被打断

### 6.5 Redis 事务三特性
1. 单独的隔离操作
2. 没有隔离级别的概念
3. 不保证原子性
* 队列中的命令未提交前都不会实际被执行。事务中一条命令执行失败，其后命令仍执行，没有回滚



## 7. Redis 持久化之 RDB
### 7.1 是什么
* 在指定的时间间隔内将内存中的数据集快照写入磁盘，即 Snapshot 快照，恢复时将快照文件直接读到内存里

### 7.2 备份是如何执行的
* Redis 会单独创建（fork）一个子进程进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束再用这个临时文件替换上次持久化好的文件。
* 整个过程中，主进程不进行任何 IO 操作，确保了极高的性能。若需进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么 RDB 比 AOF 更高效
* RDB 的缺点是最后一次持久化后的数据可能丢失

### 7.3 Fork
* Fork 的作用是复制一个与当前进程一样的进程
* 新进程的所有数（变量、环境变量、PC 等）数值与原进程一致，但是一个全新的进程，作为原进程的子进程
* Linux 程序中，子进程多会 exec 系统调用，处于效率考虑，Linux 中引入了**写时复制技术**
* 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程

### 7.4 优势
1. 适合大规模的数据恢复
2. 对数据完整性和一致性要求不高更适合使用
3. 节省磁盘空间
4. 恢复速度快

### 7.5 劣势
1. Fork 时，内存中的数据克隆了一份，2 倍膨胀
2. 虽然 Fork 时使用了写时拷贝技术，但数据庞大时还是比较消耗性能
3. 若 Redis 意外 down 掉，会丢失最后一次快照后的所有修改



## 8. Redis 持久化之 AOF
### 8.1 是什么
* 以日志的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据。换言之，Redis 重启就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

### 8.2 AOF 默认不开启
* 可修改 redis.conf 中 appendonly no 为 yes
* AOF 和 RDB 同时开启，redis 听谁的？
* 系统默认取 AOF 的数据（数据不会存在丢失）

### 8.3 Rewrite 压缩
* AOF 采用文件追加方式，文件会越来越大。为避免此情况，新增重写机制。当 AOF 文件的大小超过设定的阈值时，Redis 会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可使用命令 bgrewriteaof
* **原理：**
* AOF 文件持续增长而过大时，会 fork 出一条新进程将文件重写（先写临时文件再 rename）。redis 4.0 后的重写就是把 rdb 的快照以二进制的形式附在新的 AOF 头部，作为已有历史数据，替换原来的流水账操作
* **触发机制，重写条件：**
* Redis 会记录上次重写时 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64 M 时触发

### 8.4 AOF 持久化流程
1. 客户端的请求写命令会被 append 追加到 AOF 缓冲区内
2. AOF 缓冲区根据 AOF 持久化策略 [always, everysee, no] 将操作 sync 同步到磁盘的 AOF 文件中
3. AOF 文件大小超过重写策略或重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量
4. Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的

### 8.5 优势
1. 备份更稳健，丢失数据概率更低
2. 可读的日志文本，通过操作 AOF 稳健，可以处理误操作

### 8.6 劣势
1. 比 RDB 占用更多磁盘空间
2. 恢复备份速度更慢
3. 每次读写都同步有一定的性能压力
4. 存在个别 bug，造成恢复不能



## 9. Redis 主从复制
### 9.1 是什么
* 主机数据更新后根据配置和策略，自动同步到备机的 master / slaver 机制
* Master 以写为主
* Slaver 以读为主

### 9.2 能干嘛
1. 读写分离，性能扩展
2. 容灾快速恢复

### 9.3 常见问题
#### 9.3.1 一主二仆
* slave 1 和 slave 2 是 master 的仆机，若 slave 2 宕机，master 写入 key 4。当 slave 2 重新启动时会变为主机，需重新设置为 master 仆机，设置后可看到 key 4。若主机宕机，仆机不变。当主机重新启动，主机仆机状态回到之前

#### 9.3.2 薪火相传
* 上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险

#### 9.3.3 反客为主
* 当一个 master 宕机后，后面的 slave 可立刻升为 master，其后面的 slave 不用做任何修改

### 9.4 复制原理
1. 当从服务器连上主服务器后，从服务器向主服务器发送进行数据同步消息
2. 主服务器接到从服务器发送过来同步消息，把主服务器数据进行持久化，rdb 文件，把 rdb 文件发送从服务器，从服务器拿到 rdb 进行读取

### 9.5 哨兵模式
* 反客为主自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库
* 从下线的主服务的所有从服务中挑选一个从服务转为从服务，选择条件依次为：
    1. 选择优先级靠前的
    2. 选择偏移量最大的
    3. 选择 runid 最小的
* 挑选出新的主服务之后，sentinel 向原主服务的从服务发送 slaveof 新主服务命令，复制新 master。当已下线的服务重新上线时，sentinel 会向其发送 slaveof 命令，让向成为新主的从服务
> 注：偏移量是指获得原主机数据最全的
> 每个 redis 实例启动后都会随机生成一个 40 位的 runid



## 10. Redis 集群
### 10.1 什么是集群
* Redis 集群实现了对 Redis 的水平扩容，即启动 N 个 redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1 / N。
* Redis 集群通过分区来提供一定程度的可用性：即使集群中有一部分节点失效或无法进行通讯，集群也可以继续处理命令请求
* 取代代理服务器，无中心化集群提供服务

### 10.2 slots 插槽
* 一个 Redis 集群包含 16384 个插槽，数据库中每个键都属于这 16384 个插槽其中之一
* 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽，其中 CRC16(key) 语句用于计算 key 的 CRC16 校验和
* 集群中每个节点负责处理一部分插槽

### 10.3 分配原则
* 尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不再一个 IP 地址上

### 10.4 故障恢复
* 若集群中某台主机宕机，其从机会代替成为主机，当原主机恢复后成为新主机的从机
* 若某段插槽的主从都宕机，此时若 cluster-require-full-coverage 为 yes，则整个集群都宕机，若为 no，则该插槽数据全部不能使用，也无法存储

### 10.5 优势
1. 实现扩容
2. 分摊压力
3. 无中心配置相对简单

### 10.6 劣势
1. 多键操作不被支持
2. 多键 Redis 事务不被支持
3. 整体迁移复杂度较大



## 11. Redis 应用问题解决
### 11.1 缓存穿透
![缓存穿透](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/缓存穿透.1p7xovhxqku8.png)

**现象：**
1. 应用服务器压力变大了
2. Redis 命中率降低
3. 一直查询数据库

**原因：**
1. Redis 查询不到数据库
2. 出现很多非正常 url 访问

**解决方案：**
1. 对空值缓存
    - 若一个查询返回的数据为空（不管数据是否不存在），仍把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过 5 min
2. 设置可访问的名单（白名单）
    - 使用 bitmaps 类型定义一个可访问名单，名单 id 作为 bitmaps 偏移量，每次访问和 bitmaps 里面的 id 比较，不在则拦截，不允许访问
3. 采用布隆过滤器
    - 将所有可能存在的数据哈希到一个足够大的 bitmaps 一个一定不存在的数据会被其拦截
4. 进行实时监控
    - 当发现 Redis 命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务

### 11.2 缓存击穿
**现象：**
1. 数据库访问压力瞬时增加
2. redis 里没有出现大量 key 过期
3. redis 正常运行

**原因：**
* redis 某个 key 过期了，同时大量访问使用这个 key

**解决方案：**
1. 预先设置热门数据
2. 实时调整
3. 使用锁

<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/缓存击穿.5l2li4pfaag0.png" alt="缓存击穿" width="70%" align=center>

### 11.3 缓存雪崩
**现象：**
* 数据库压力变大，服务器崩溃

**原因：**
* 在极少时间段，查询大量 key 集中过期情况

**解决方案：**
1. 构建多级缓存架构
    - nginx 缓存 + redis 缓存 + 其他缓存
2. 使用锁或队列
    - 不适用高并发情况
3. 设置过期标志更新缓存
    - 记录缓存数据是否过期（设置提前量），若过期会触发通知另外的线程去后台更新实际 key 的缓存
4. 将缓存失效时间分散开
    - 如在原有失效时间基础上增加一个随机值，如 1-5 分钟，这样每个缓存的过期时间的重复率会降低，就很难引发集体失效事件

### 11.4 分布式锁
#### 11.4.1 问题描述
* 一种跨 JVM 的互斥机制来控制共享资源的访问（一机上锁，集群其他机均上锁，解锁同理）
* 分布式锁方案：
    1. 性能：redis 最高
    2. 可靠性：zookeeper 最高

#### 11.4.2 Redis 分布式锁
1. 使用 setnx 上锁，通过 del 释放锁
2. 锁一直未释放，设置 key 过期时间，自动释放
3. 上锁后突然异常，无法设置过期时间，上锁同时设置过期时间即可
```
set users 10 nx ex 12
```

#### 11.4.3 Redis 分布式锁优化
* 为保证分布式锁可用，需确保锁实现满足四个条件：
1. **互斥性**。在任意时刻，只有一个客户端能持有锁
2. **不会发生死锁**。即使有一个客户端在持有锁的期间崩溃而没有主动释放锁，也能保证后续客户端能加锁（通过设置过期时间）
3. **解铃还须系铃人**。加锁和解锁必须是同一客户端，客户端自己不能把别人加的锁解了（通过 UUID 防误删）
4. **加锁和解锁必须具有原子性**（通过 LUA 脚本保证删除原子性）
* 解释：a 在释放锁前到了过期时间，自动释放，但还未进行删除操作，此时 b 上锁，导致 a 释放操作时释放了 b 的锁



## 12. IO 多线程
* 指客户端交互部分的网络 IO 交互处理模块多线程，Redis 执行命令依然是单线程
* 多线程部分只是用来处理网络数据的读写和协议解析