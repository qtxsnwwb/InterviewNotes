# 网络协议分层
* 5 层协议栈
    * 应用层
    > 为操作系统或网络应用程序提供访问网络服务的接口
    > 数据传输基本单位为报文
    > 包含的主要协议：FTP、DNS、SMTP、HTTP
    * 运输层
    > 根据网络地址将源结点发出的数据包传送到目的结点，传输层负责将数据可靠地传送到相应的端口
    > 数据传输基本单位为报文段
    > 包含的主要协议：TCP、UDP
    > 重要设备：网关
    * 网络层
    > 负责对子网间的数据包进行路由选择。还可实现拥塞控制、网际互连等功能
    > 数据传输的基本单位为 IP 数据报
    > 包含的主要协议：IP、ICMP、ARP
    > 重要设备：路由器
    * 链路层
    > 将源自网络层来的数据可靠地传输到相邻结点的目标机网络层
    > 链路层为网络层提供可靠的数据传输
    > 基本数据单位为帧
    > 主要协议：以太网协议
    > 重要设备：网桥和交换机
    * 物理层
    > 为上层协议提供了一个传输数据的可靠地物理媒体。确保原始的数据可在各种物理媒体上传输
* 7 层 ISO OSI 模型
    * 应用层
    * 表示层
    * 会话层
    * 运输层
    * 网络层
    * 链路层
    * 物理层



# get 和 post 的区别
1. get 请求在浏览器后退时无害，不发送请求。post 在浏览器后退时会再次发送请求
2. get 参数通常在 url 后面传递，post 则通常在 Request body 中传递
3. get 比 post 更不安全。因为参数直接暴露在 url
4. get 在 url 中传输参数有长度限制，post 没有限制
5. get 产生一个 TCP 数据包，post 产生两个。对于 get 请求，浏览器会把 http header 和 data 一并发送；而 post 则先发 header，服务器响应100，再发送 data，响应 200。（Firefox 例外，只发一次）



# http 2.0 和 http 1.x 的区别
1. http 1.x 的解析是基于文本协议的各式解析，而 http 2.0 的协议解析是二进制格式，更加强大
2. 多路复用：一个连接上可以有多个 request，且可以随机混在一起，每个不同的 request 都有对应 id，服务端可通过 request_id 辨别，大大加快了传输速率
3. header 压缩：http 1.x 中的 header 需携带大量信息，而且每次都需要重复发送。http 2.0 使用 encode 来减少传输的 header 大小。而且客户端和服务端可以各自缓存一份 header field 表，避免了 header 的重复传输，还可以减少传输的大小
4. 服务端推送：可以通过解析 html 中的依赖，智能地返回所需的其他文件（css 或 js 等），而不用再发起一次请求




# UDP 和 TCP 的区别
* UDP：无连接，尽最大可能交付，没有拥塞控制，面向报文（对应用程序传下来的报文不合并不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信
* TCP：面向连接，提供可靠支付，有流量控制、拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）



# TCP 三次握手
* ACK：该位设为 1，确认应答的字段有效，TCP 规定除了最初建立连接时的 SYN 包之外，该位必须为 1
* SYN：用于建立连接，设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定
![TCP三次握手](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/TCP三次握手.4pes0ajt2j60.png)

* 第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号 x，客户端向服务端发送的报文段包含 SYN 标志（SYN = 1），序列号 seq = x
* 第二次握手：服务端收到客户端发过来的报文后，发现 SYN = 1，知道这是一个连接请求，于是将客户端起始序列号 x 存起来，并且随机生成一个服务端起始序列号 y，然后回复报文，包含 SYN 和 ACK 标志（SYN = 1，ACK = 1）、序列号 seq = y、确认号 ack = x + 1
* 第三次握手：客户端收到服务端报文发现 ACK = 1 且 ack = x + 1，于是知道服务端已经收到了序列号为 x 的报文；同时发现 SYN = 1，知道了服务端同意了这次连接，于是将服务端序列号 y 存下来。然后客户端再回复一段报文给服务端，包含 ACK 标志（ACK = 1），ack = y + 1，seq = x + 1，当服务端收到报文后知道客户端收到序列号为 y 的报文，于是建立了 TCP 连接
> 说明：第三次握手回复的报文中 seq = x + 1 是因为不携带数据的 ACK 报文不占据序列号



# TCP四次挥手
* seq：占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记
* ack：占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack = seq + 1
* FIN：释放一个连接
![TCP四次挥手](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/TCP四次挥手.496otmrb15c0.png)

* 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文（数据没发完时也可以发送连接释放报文并停止发送数据），包含 FIN 标志（FIN = 1），序列号 u（u = 连接成功后客户端发送的数据量 + x + 1）
> 客户端发出 FIN 报文段后只是不能发数据了，但还可以正常收数据。FIN 报文即使不携带数据也要占一个序列号
* 第二次挥手：服务端收到客户端发出的 FIN 报文后给客户端回复确认报文，包含 ACK 标志（ACK = 1）、确认号 ack = u + 1、序列号 v（v = 服务端在客户端发 FIN 报文前总共回复数据量 + y）。此时服务端处于关闭等待状态，而不是立马给客户端发 FIN 报文。这个状态还要持续一段时间，因为服务端**可能还有数据没发完**。
* 第三次挥手：服务端将最后数据发送完毕后就向客户端发出连接释放报文，包含 FIN 和 ACK 标志（FIN = 1，ACK = 1）、确认号 ack = u + 1、序列号 w（w = v + 最后发送的数据量）
* 第四次挥手：客户端收到服务端发的 FIN 报文后，向服务端发出确认报文，确认报文包含 ACK 标志（ACK = 1）、确认号 ack = w + 1、序列号 seq = u + 1
> 客户端发出确认报文后不是立马释放 TCP 连接，而是要经过 2 MSL（最长报文段寿命的 2 倍时长）后才释放 TCP 连接。而服务端一旦收到客户端发出的确认报文就会立马释放 TCP 连接，所以服务端结束 TCP 连接的时间要比客户端早一些。



**为什么 TCP 连接时是 3 次？2 次不可以吗？**

```
	因为需要考虑连接时丢包的问题，如果只握手 2 次，第二次握手时若服务端发给客户端的确认报文段丢失，此时服务端已连接成功，而客户端一直没收到确认报文，所以客户端就不知道服务端是否已准备好了，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。
	如果是三次握手，则丢包也无妨。例如若第三次握手客户端发的 ack 报文丢失，服务端在一段时间收不到确认报文，会重新进行第二次握手。
```


**为什么 TCP 连接的时候是 3 次，关闭却是 4 次？**
```
	因为只有在客户端和服务端都没有数据要发送时才能断开 TCP。而客户端发出 FIN 报文时智能保证客户端没有数据发了，服务端有没有不知道。而服务端收到客户端的 FIN 报文后只能先回复一个确认报文告诉客户端服务端已收到 FIN 报文，但服务端还有数据没发完。所以不能一次性将确认报文和 FIN 报文发给客户端，就是这里多出一次。
```


**为什么客户端发出第四次挥手的确认报文后要等 2 MSL 的时间才能释放 TCP 连接？**
```
	同样是考虑丢包问题，如果第四次挥手的报文丢失，服务端没收到确认 ack 报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是 2 MSL，所以需要等这么长时间确认服务端确已收到。
```


**如果已建立连接，但客户端突然出现故障怎么办？**
```
	TCP 设有一个保活计时器。服务器每收到一次客户端请求后会复位这个计时器，时间通常是 2 小时。若 2 小时没收到客户端任何数据，服务器就会发送一个探测报文段，以后每 75 s 发一次，若连续 10 次没反应，则认为客户端出了故障，关闭连接。
```



# HTTP 和 HTTPS 的区别
* 协议：http 运行在 TCP 之上，明文传输，客户端与服务端都无法验证对方身份；https 运行于 SSL 上，SSL运行于 TCP 之上，是添加了加密和认证机制的 http
* 端口：http—80；https—443
* 资源消耗：http—较少；https—由于加解密处理，会消耗更多的 CPU 和内存资源
* 开销：http—无需证书；https—共享密钥加密和公开密钥加密并用的混合加密机制
* 安全性：http—弱；https—由于加密机制，安全性强



# 完整的 HTTP 请求过程
1. 浏览器进行 DNS 域名解析，得到对应的 IP 地址
2. 根据这个 IP，找到对应的服务器建立连接（三次握手）
3. 建立 TCP 连接后发起 HTTP 请求（一个完整的 http 请求报文）
4. 服务器响应 HTTP 请求，浏览器得到 html 代码
5. 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户
7. 服务器关闭 TCP 连接（四次挥手）



# DNS 解析
1. 首先会搜索浏览器自身的 DNS缓存
2. 若浏览器自身的缓存里没有找到，那么浏览器会搜索操作系统的 DNS 缓存
3. 若没找到则从 hosts 文件找
4. 若 1、2、3 均未找到，浏览器会发起一个 DNS 的系统调用，就会向本地配置的首选 DNS 服务器发起域名解析请求（通过 UDP 向DNS 的 53 端口发起请求，该请求是递归的，从根域名服务器逐渐向顶层递归遍历）



**三次握手过程中发生丢包怎么办？**
*超时重传机制*
* 若第一个包，A 发给 B 请求连接的报文（SYN）丢失，A 会周期性超时重传，直到 B 发出确认（SYN + ACK）
* 若第二个包，B 发给 A 的确认报文（SYN + ACK）丢失，B 会周期性超时重传，直到 A 发出确认（ACK）
* 若第三个包，A 发给 B 的确认报文（ACK）丢包
    * A 在发送完确认报文后，A 单方面进入 ESTAB-LISHED 状态，B 还是处于 SYN-RCVD
    * 若此时双方无数据发送，B 会周期性超时重传（SYN + ACK），直到 A 发出确认报文（ACK），此时 B 也进入了 ESTAB-LISHED
    * 若 A 有数据发送，A 发送的是（ACK + Data），B 收到后会进入 ESTAB-LISHED，并接受数据
    * 若 B 有数据发送，B 是发送不了的，会周期性超时重传（SYN + ACK）直到 A 的确认（ACK）B 才能发送数据



# TCP 流量控制方法
1. 停止—等待协议
```
	每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。
```
2. 滑动窗口机制（TCP 采用）
```
	在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口 rwnd(接收方设置确认报文段的窗口字段来将 rwnd 通知给发送方)，发送方的发送窗口取接收窗口 rwnd 和拥塞窗口 cwnd 最小值。
	TCP 为每个连接设有一个持续计时器，只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。若窗口仍然是 0，那么发送方就重新设置持续计时器。
```
> 后退 N 步协议（GBN）
> 选择重传协议（SR）



# TCP 实现可靠传输的机制
* TCP 的发送方在规定时间（重传时间）内没有收到确认就要重传已发送的报文段（超时重传）
* TCP 采用自适应算法，动态改变重传时间 RTTs（加权平均往返时间）
* 冗余 ACK（冗余确认）—> 快速重传
* 每当比期望序号大的失序报文段到达时，发送一个冗余 ACK，指明下一个期待字节的序号
> 发送方已发送 1, 2, 3, 4, 5 报文段
> 接收方收到 1，返回给 1 的确认（确认号为 2 的第一个字节）
> 接收方收到 3，返回给 1 的确认（确认号为 2 的第一个字节）
> 接收方收到 4，返回给 1 的确认（确认号为 2 的第一个字节）
> 接收方收到 5，返回给 1 的确认（确认号为 2 的第一个字节）
> 发送方收到 **3 个对于报文段 1 的冗余 ACK** —> 认为 2 报文段丢失，重传 2 号报文段



# TCP 拥塞控制四种算法
1. 慢开始
```
	cwnd = 1，一个报文段，指数规律增长，直到达到 ssthresh（慢开始门限）
```
2. 拥塞避免
```
	加法增大 cwnd，直到达到网络拥塞，然后缩小到 1，重新开始慢开始，设定新的门限值为网络拥塞值 cwnd 大小的一半
```
3. 快重传
```
	cwnd 达到网络拥塞时，收到 3 个重复的确认则执行快重传算法
```
4. 快恢复
```
	当符合快重传条件时，cwnd 降到网络拥塞 cwnd 的一半，然后执行拥塞避免过程
```



# 三种路由协议比较

| 协议     | RIP                                        | OSPF                                 | BGP                                    |
| -------- | ------------------------------------------ | ------------------------------------ | -------------------------------------- |
| 类型     | 内部                                       | 内部                                 | 外部                                   |
| 路由算法 | 距离-向量                                  | 链路状态                             | 路径-向量                              |
| 传递协议 | UDP                                        | IP                                   | TCP                                    |
| 路径选择 | 跳数最少                                   | 代价最低                             | 较好，非最佳                           |
| 交换结点 | 和本结点相邻的路由器                       | 网络中的所有路由器                   | 和本结点相邻的路由器                   |
| 交换内容 | 当前本路由器知道的全部信息，即自己的路由表 | 与本路由器相邻的所有路由器的链路状态 | 首次：整个路由表；非首次：有变化的部分 |

