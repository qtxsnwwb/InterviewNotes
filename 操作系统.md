# I/O 操作分类
1. 直接访问：由用户进程直接控制主存或 CPU 和外围设备之间的信息传送
2. 中断驱动：为了减少程序直接控制方式下 CPU 的等待时间以及提高系统的并行程度。外围设备仅当操作正常结束或异常结束时才向 CPU 发出中断请求，在 I/O 设备输入每个数据中，由于无需 CPU 的干预，实现了 CPU 与 I/O 的并行工作
3. DMA：通过硬件即 DMA 控制器，实现存储器与设备、设备与设备之间的数据传输，不需要处理器的参与，可实现大批量数据的快速传输。
4. 通道：独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换，可与中央处理器并行工作



# 进程状态转换图
![进程状态转换图](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/进程状态转换图.55dbcurg23g0.png)
* 运行-阻塞：正在执行的进程因发生某等待事件而无法执行，如进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态
* 阻塞-就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，先转入就绪状态，再由系统进程调度程序在适当时候转为运行态



# 进程间通信方式
## 1. 管道
* 利用文件系统的功能，通信双方的进程共享同一个文件，发送进程向文件写数据，接收进程读数据，打开的共享文件类似管道

## 2. 消息队列
* 每个进程对应一个消息缓冲队列，发送进程利用发送操作，将数据组织在消息缓冲区中，并将消息缓冲区加入接收进程的消息缓冲区队列中，接收进程从自己的消息缓冲区队列取出消息缓冲区，从而得到数据

## 3. 共享内存
* 建立一个共享存储区域，通信时将这个区域地址映射到发送进程的地址空间，使发送进程可以访问该区域。同时也映射到接收进程的地址空间，使接收进程也可以访问

## 4. 信号量
* 计数器，实现进程间的同步和互斥

## 5. 套接字
* 多机情况下多个进程的通信方式



# 进程调度
## 1. 进程调度方式
### (1). 非抢占方式
* 运行的进程让它继续，除非其自身的原因让出处理器，否则一直运行至完成为止

### (2). 抢占方式
* 系统可以基于某些原则，在没有任何警告的情况下，让运行的进程停下来，把处理器分配给下一个进程，如时间片原则、优先级原则等

## 2. 进程调度算法
### (1). 先来先服务（FCFS）
* 按进入就绪队列的先后顺序调度

### (2). 短进程优先
* 进程运行所需占用处理器时间短的优先

### (3). 时间片轮转（RR）
* 就绪队列按先进先出方式组织
* 调度时选择一个进程，并分配一个时间片
* 选中的进程在规定的时间片内运行

### (4). 优先级算法
* 对每个进程给予一个优先数，调度时选择优先级最高的进程



# 虚拟内存
* 计算机系统内存管理的一种技术。使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）。实际上，它通常是被分割成多个物理内存碎片，还有部分存储在外部磁盘存储器上，在需要时进行数据交换。



# 页面置换算法
1. 先进先出算法（FIFO）
* 将内存中的页按装入内存的先后顺序排列，淘汰时选择最先进入内存的页
2. 最近最久未使用算法（LRU）
* 页表中登记每个页被 CPU 访问的时间，淘汰时选择最近一段时间最久没有被访问的页
3. 最近最不常用算法（LFU）
* 淘汰时选择最近一段时间被访问最少的页

> 颠簸
> 对于内存中的页，若被置换算法选中淘汰，则在系统的将来运行过程中，可能还会被访问，因而又产生缺页中断，又需将其再次读入内存。故而可能出现频繁调出调入某一页的情况，称为颠簸。



# 局部性原理
* 在程序运行过程的一个较小时间范围内，只需要一小部分的程序信息，其他部分暂时不需要；而且在程序一次执行过程中，程序的所有指令和数据并没有相同的访问概率，有的经常被访问，有的很少
* 时间局部性：某一个地址的存储单元信息被访问后，在不久后，这个地址的存储单元信息被再次访问的概率很大
* 空间局部性：某一个地址的存储单元信息被访问后，在不久后，与这个地址相邻的存储单元信息被访问的概率很大

> 程序的局部性原理表明：
> 对于大多数程序，在运行过程中，若某些指令或数据经常被访问，那么，在接下来的运行中，这些指令或数据还将经常地被访问



# 协程
* 基于线程之上，比线程更加轻量级的存在，由程序员自己写程序来管理的轻量级线程叫用户空间线程，对内核不可见。
* **一个线程可以有多个协程**
* 目的：当出现长时间的 I/O 操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除 ContextSwitch 上的开销
* 特点：
    - 线程切换由操作系统调度，协程由用户自己调度，因此减少了上下文切换。
    - 协程更轻量，可以在相同内存中开启更多协程
    - 由于在同一个线程上，可以避免竞争关系而使用锁。适用于被阻塞且需要大量并发的情景，不适用于大量计算的多线程
* 原理：当出现 I/O 阻塞时，由协程的调度器进行调度，通过将数据流立刻 yield 掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞结果放到这个线程上跑

