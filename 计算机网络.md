# 网络协议分层
* 5 层协议栈
    * 应用层
    > 为操作系统或网络应用程序提供访问网络服务的接口
    > 数据传输基本单位为报文
    > 包含的主要协议：FTP、DNS、SMTP、HTTP
    * 运输层
    > 根据网络地址将源结点发出的数据包传送到目的结点，传输层负责将数据可靠地传送到相应的端口
    > 数据传输基本单位为报文段
    > 包含的主要协议：TCP、UDP
    > 重要设备：网关
    * 网络层
    > 负责对子网间的数据包进行路由选择。还可实现拥塞控制、网际互连等功能
    > 数据传输的基本单位为 IP 数据报
    > 包含的主要协议：IP、ICMP、ARP
    > 重要设备：路由器
    * 链路层
    > 将源自网络层来的数据可靠地传输到相邻结点的目标机网络层
    > 链路层为网络层提供可靠的数据传输
    > 基本数据单位为帧
    > 主要协议：以太网协议
    > 重要设备：网桥和交换机
    * 物理层
    > 为上层协议提供了一个传输数据的可靠地物理媒体。确保原始的数据可在各种物理媒体上传输
* 7 层 ISO OSI 模型
    * 应用层
    * 表示层
    * 会话层
    * 运输层
    * 网络层
    * 链路层
    * 物理层



# get 和 post 的区别
1. get 请求在浏览器后退时无害，不发送请求。post 在浏览器后退时会再次发送请求
2. get 参数通常在 url 后面传递，post 则通常在 Request body 中传递
3. get 比 post 更不安全。因为参数直接暴露在 url
4. get 在 url 中传输参数有长度限制，post 没有限制
5. get 产生一个 TCP 数据包，post 产生两个。对于 get 请求，浏览器会把 http header 和 data 一并发送；而 post 则先发 header，服务器响应100，再发送 data，响应 200。（Firefox 例外，只发一次）



# http 2.0 和 http 1.x 的区别
1. http 1.x 的解析是基于文本协议的各式解析，而 http 2.0 的协议解析是二进制格式，更加强大
2. 多路复用：一个连接上可以有多个 request，且可以随机混在一起，每个不同的 request 都有对应 id，服务端可通过 request_id 辨别，大大加快了传输速率
3. header 压缩：http 1.x 中的 header 需携带大量信息，而且每次都需要重复发送。http 2.0 使用 encode 来减少传输的 header 大小。而且客户端和服务端可以各自缓存一份 header field 表，避免了 header 的重复传输，还可以减少传输的大小
4. 服务端推送：可以通过解析 html 中的依赖，智能地返回所需的其他文件（css 或 js 等），而不用再发起一次请求




# UDP 和 TCP 的区别
* UDP：无连接，尽最大可能交付，没有拥塞控制，面向报文（对应用程序传下来的报文不合并不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信
* TCP：面向连接，提供可靠支付，有流量控制、拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）



# TCP 三次握手
* ACK：该位设为 1，确认应答的字段有效，TCP 规定除了最初建立连接时的 SYN 包之外，该位必须为 1
* SYN：用于建立连接，设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定
![TCP三次握手](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/TCP三次握手.4pes0ajt2j60.png)

* 第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号 x，客户端向服务端发送的报文段包含 SYN 标志（SYN = 1），序列号 seq = x
* 第二次握手：服务端收到客户端发过来的报文后，发现 SYN = 1，知道这是一个连接请求，于是将客户端起始序列号 x 存起来，并且随机生成一个服务端起始序列号 y，然后回复报文，包含 SYN 和 ACK 标志（SYN = 1，ACK = 1）、序列号 seq = y、确认号 ack = x + 1
* 第三次握手：客户端收到服务端报文发现 ACK = 1 且 ack = x + 1，于是知道服务端已经收到了序列号为 x 的报文；同时发现 SYN = 1，知道了服务端同意了这次连接，于是将服务端序列号 y 存下来。然后客户端再回复一段报文给服务端，包含 ACK 标志（ACK = 1），ack = y + 1，seq = x + 1，当服务端收到报文后知道客户端收到序列号为 y 的报文，于是建立了 TCP 连接
> 说明：第三次握手回复的报文中 seq = x + 1 是因为不携带数据的 ACK 报文不占据序列号



# TCP四次挥手
* seq：占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记
* ack：占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack = seq + 1
* FIN：释放一个连接
![TCP四次挥手](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/TCP四次挥手.496otmrb15c0.png)

* 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文（数据没发完时也可以发送连接释放报文并停止发送数据），包含 FIN 标志（FIN = 1），序列号 u（u = 连接成功后客户端发送的数据量 + x + 1）
> 客户端发出 FIN 报文段后只是不能发数据了，但还可以正常收数据。FIN 报文即使不携带数据也要占一个序列号
* 第二次挥手：服务端收到客户端发出的 FIN 报文后给客户端回复确认报文，包含 ACK 标志（ACK = 1）、确认号 ack = u + 1、序列号 v（v = 服务端在客户端发 FIN 报文前总共回复数据量 + y）。此时服务端处于关闭等待状态，而不是立马给客户端发 FIN 报文。这个状态还要持续一段时间，因为服务端**可能还有数据没发完**。
* 第三次挥手：服务端将最后数据发送完毕后就向客户端发出连接释放报文，包含 FIN 和 ACK 标志（FIN = 1，ACK = 1）、确认号 ack = u + 1、序列号 w（w = v + 最后发送的数据量）
* 第四次挥手：客户端收到服务端发的 FIN 报文后，向服务端发出确认报文，确认报文包含 ACK 标志（ACK = 1）、确认号 ack = w + 1、序列号 seq = u + 1
> 客户端发出确认报文后不是立马释放 TCP 连接，而是要经过 2 MSL（最长报文段寿命的 2 倍时长）后才释放 TCP 连接。而服务端一旦收到客户端发出的确认报文就会立马释放 TCP 连接，所以服务端结束 TCP 连接的时间要比客户端早一些。