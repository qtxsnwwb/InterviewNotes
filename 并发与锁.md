# CAS

Compare And Swap 比较并替换

### 定义：
```
	CAS 操作包含三个操作数——内存位置（V）、期望值（A）和新值（B）。若V与A值相匹配，那么处理器会自动将该位置更新为新值（B），否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。
```

### CAS 实现原理：
```
	CAS 通过调用JNI 的代码实现。
```
> JNI：Java Native Interface，允许Java调用其他语言  

Compare And Swap XXX 系列的方法就是借助 C 语言来调用 CPU 底层指令实现的。  
以常用的 Intel x86 来说，最终映射到的CPU指令为“cmpxchg”，这是一个原子指令。CPU 执行它实现比较并替换的操作。

**cmpxchg 如何保证多核心下的线程安全？**
```
	系统底层进行 CAS 操作时，会判断当前系统是否为多核心系统，如果是就给“总线”加锁，只有一个线程会对总线加锁成功。加锁成功后会执行 CAS，也就是说 CAS 的原子性是平台级别的。
```

### ABA 问题
```
	CAS 需要再操作值的时候检查下值有没有变化，如果没有变化则更新。但是如果原来一个值是 A，在 CAS 执行前改为了 B，然后又改回了 A，那么 CAS 执行检查时会发现它的值没有变化，但是实际却变化了，这就是 ABA 问题。
```

**如何解决 ABA 问题？**
```
	给值加一个修改版本号，每次值变化，都会修改它的版本号，CAS 操作时都去对比此版本号。 
```

---
**参考：**[面试必问】Java并发基石-CAS原理实战 超详细 超多案例 全B站最牛版](https://www.bilibili.com/video/BV1kE411u7bj?from=search&seid=4752645302949684165)



# AQS

队列同步器，是一个**同步器 + 阻塞锁**的架构，用于控制加锁和释放锁。内部维护一个FIFO的线程等待队列（双向链表实现），当多线程争用资源被阻塞时会进入此队列。

### 1. AQS 的同步状态关键字
```java
private volatile int state
```
* state 用来表示线程争抢的资源
    * 若为 n（n > 0） --> 有 n 个线程正在等待资源释放
    * 若为 0 --> 没有线程正在等待资源
* AQS 通过 getState、setState、CAS 访问 state 

### 2. 线程安全三要素
> * 原子性
> * 可见性
> * 有序性

### 3. AQS 的等待队列
```
	AQS原理：每当有新的线程请求资源的时候，该线程都会进入一个等待队列，只有当持有锁的线程释放资源之后，该线程才能持有资源。
```

### 4. 等待队列结点两大模式
* **独占模式**：表示该锁会被一个线程占用，其他线程必须等其释放锁后才能获取锁执行（ReentrantLock 采用）
* **共享模式**：表示多个线程获取同一个锁的时候，有可能会成功（ReadLock 采用）

### 5. 等待队列结点四种等待状态
（1） 表示线程已取消
```java
static final int CANCELLED = 1
```
（2）表示竞争锁的胜者线程需要唤醒
```java
static final int SIGNAL = -1
```
（3）表示线程正在 condition 队列中等待
```java
static final int CONDITION = -2
```
（4）表示后继结点会船舶唤醒操作，只会在共享模式下起作用
```java
static final int PROPAGATE = -3
```



# ReetrantLock
重入锁，指在同一线程中，外部方法获得锁后，内层递归方法依然可以获取该锁，属显式锁，与synchronized 隐式锁相对。
即当一个线程获取对象锁之后，这个线程可以在此获取本对象上的锁，而其他线程不可以。

### 1. 公平锁与非公平锁
* ** 公平锁**：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
* **非公平锁**：在锁被释放时，任何一个等待锁的线程都有机会获得锁
> sychronized 是非公平锁，ReentrantLock 默认非公平，可使用公平锁。
> ReentrantLock 实现公平锁：判断当前线程是否具备前驱结点，只有不具备前驱结点的线程才可能持有锁（依然基于 AQS），非公平锁无上述判断。

### 2. 加锁的两种基本形式
* **互斥锁**：通过阻塞线程加锁，中断阻塞解锁
* **自旋锁**：线程保持运行态，用一个循环体不停地判断某个标识量的状态来确定加锁还是解锁

### 3. ReentrantLock 处理重入性
（1）判断 state 标量是否为 0，若为 0，那么说明没有线程持有该锁，当前线程可以持有锁，返回 true
（2）若 state 不为 0，则判断当前线程是否为锁持有者
（3）若不是，那么当前线程不能持有锁，返回 false
（4）若是，那么当前线程已经持有锁，此时认为同线程请求次数增加，state 需要增加 acquires次，acquires 表示新增的请求锁次数

### 4. 比较 Synchronized 和 ReentrantLock 优劣
```
	ReentrantLock 获得锁和释放锁的操作更加灵活，且具备独立的条件监视器，等待和唤醒线程的操作也更加方便和多样化。在多线程环境下，ReentrantLock 的执行效率也比 Synchronized高。
	但程序不仅仅是执行更快和操作更灵活就会更优秀，还要考虑维护成本。Sychronized具有完备语义，一个获得锁的操作就一定会对应一个释放锁的操作，否则会有编译期异常出现。
```

### 5. ReentrantLock 的条件监视器 Condition
**监视器**：用于监控一段同步的代码，可以用于线程的阻塞和解除阻塞
> **Condition 方法**：
>
> 1. await：等效于 Object.wait
> 2. signal：等效于 Object.notify

### 6. ReentrantLock 相比 Synchronized 新增高级功能
（1）**等待可中断**：当持有锁的线程长期不释放锁时，正在等待的线程可选择放弃等待，改为处理他事。
（2）**公平锁**：ReentrantLock 默认也为非公平锁，但可通过带布尔值的构造函数使用公平锁
（3）**锁绑定多个条件**：一个 ReentrantLock 对象可同时绑定多个 Condition 对象。Synchronized 通过 wait() 与 notify() 配合可实现一个隐含的条件，若要和多个条件关联时，不得不额外添加一个锁；ReentrantLock 只须多次调用 newCondition() 即可。




# Synchronized 原理
```
	同步块是由 monitorenter 指令进入，然后 monitorexit 释放锁，在执行 monitorenter 之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有这个对象的锁，则将锁的计数器 +1。当执行 monitorexit 指令时，锁的计数器也会 -1.当获取锁失败时会被阻塞，一直等待锁被释放。
```

### JVM 对 Synchronized 的优化
1. 偏向锁
```
	若一个线程获得了锁，锁就进入偏向模式，此时 Mark Word 结构页编程偏向锁结构。当该线程在此请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查 Mark Word 的锁标记位及当前线程 ID 等于 Mark Word 的ThreadID 即可。
```
2. 轻量级锁
```
	由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁升级为轻量级锁。此处第二个线程只是申请锁，不存在两个线程同时竞争锁，可一前一后交替执行同步块。
```
3. 重量级锁
```
	由轻量级锁升级而来，当同一时间有多个线程竞争时，锁会升级为重量级锁，此时申请锁带来的开销也变大。重量级锁一般会应用在追求吞吐量，同步块或同步方法执行时间较长的场景。
```
4. 锁消除
```
	在 JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁
```
5. 锁粗化
```
	通过扩大锁的范围，避免反复加锁和释放锁
```
6. 自旋锁
```
	通过让线程执行循环等待锁的释放，不让出 CPU。如果得到锁，就顺利进入临界区。如果还不能获取锁，就会将线程在操作系统层面挂起。
```
7. 自适应自旋锁
```
	对自旋锁的进一步优化，自旋次数不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。解决了自旋锁带来的缺点。
```



# 线程池
**概念**
* 核心线程数：线程池的基本大小
* 最大线程数：同一时刻线程池中线程的数量最大不能超过该值
* 任务队列：当任务较多时，线程池中线程数量已达到了核心线程数，此时就是用任务队列来存储我们提交的任务

> 线程池基于生产者--消费者模式来实现

<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/线程池执行流程.2hgyxu2zk8s0.png" width="60%" alt="线程池执行流程" align=center />




# volatile 关键字
volatile 保证了**可见性**和**有序性**，但不保证操作的**原子性**
**1. 可见性保证**

* 当一条线程修改了变量的值，新值对于其他线程来说是可以立即得知的  

**2. 禁止指令重排序优化（有序性）**

* 具体操作：加 lock 指令，相当于一个内存屏障，重排序时不能把后面的指令重排序到内存屏障之前的位置
* volatile 变量读操作的性能消耗与普通变量几乎无差别，但写会慢，因为需要再本地代码中插入许多内存屏障指令（lock）来保证处理器不发生乱序执行



**i++ 线程安全问题**

* i++并非线程安全
* i++ 并非原子操作，其执行过程为读取 i 值，i 加 1，再赋值给 i。以上过程均在线程的工作内存完成，最终再刷回主内存。
* 如果一个线程运算完还没刷到主内存，此时这个共享变量被另外一个线程从主内存读取到了，此时读到的就是脏数据
* 这就是典型的**内存不可见**问题
> 若给 i 加上 volatile 让内存可见是否能解决？
> 不能。volatile 只能保证可见性，不能保证原子性。可保证其他线程修改的可见性，不能保证线程之间读取到同样的值然后相互覆盖对方值的情况。

> 解决方案：
> 1. 对 i++ 加同步锁，同时只能有一个线程执行 i++
> 2. 使用支持原子性操作的类，如 AtomicInteger，它使用的是 CAS 算法