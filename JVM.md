# 对象创建流程图
<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/对象创建步骤流程图.3sv9496yg7s0.png" alt="对象创建步骤流程图" width="35%" align=center />



# 对象的内存布局
![对象的内存布局](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/对象的内存布局.2ydkr8779ge0.png)



# 对象的访问定位
### 对象的存储分为 3 部分：
1. 堆中存储对象实例数据，以及指向对象类型数据的指针
2. 方法区中存储对象类型数据（类信息：访问权限，类名等）
3. 虚拟机栈的局部变量表中存储对象引用（reference 类型）

### 句柄池访问：
* reference 指向对象的句柄地址（位于堆中），句柄地址包括指向堆中对象实例数据的指针和指向方法区中对象类型数据的指针



# 堆溢出和栈溢出
### 堆溢出
```
	每个方法创建时都会创建一个栈帧，栈溢出就是创建的栈帧超过了栈的深度。最有可能的原因就是方法递归调用产生的
```

### 堆溢出
```
	堆中存储的主要是对象，如果不断地 new 对象，则会导致堆中的空间溢出
```

### 内存泄漏和内存溢出
* 内存泄漏：程序在申请内存后，无法释放已申请的内存空间。内存泄漏堆积的后果是内存溢出
* 内存溢出：程序申请内存时，没有足够的内存供申请者使用

### 内存溢出的原因：
1. 内存中加载的数据量过于庞大，如一次数据库取出过多数据
2. 集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收
3. 代码中存在死循环或循环产生过多重复的对象实体
4. 使用的第三方软件中的 bug
5. 启动参数内存值设定的过小

### 内存溢出的解决方案
1. 修改 JVM 启动参数，直接增加内存
2. 检查错误日志，查看 OutOfMemory 前是否有其他异常或错误
3. 对代码进行走查和分析，找出可能发生内存溢出的位置

> Java 中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还必须拥有一个与原方法不同的特征签名。
> 特征签名指一个方法中各个参数在常量池中的字段符号引用的集合。返回值不属于特征签名，因此 Java 无法仅仅依靠返回值不同来对已有方法重载。



**静态变量（类变量）的初始化与存储**

* 类加载的准备阶段会为类变量分配内存并设置初始值。JDK 8 之后，类变量会随着 Class 对象一起存放在 Java 堆中。设置的初始值为 0。对类变量的赋值是在初始化阶段调用<clinit>完成，非类变量（实例变量）赋值是在初始化阶段调用<init>完成。
* 若 final 修饰了类变量，并且这个变量的数据类型是基本类型或 java.lang.String，则再准备阶段会被初始化为 ConstantValue 指定的值。

> JDK 8 之后取消了永久代，将永久代存储的信息一分为二，一部分为元空间，存储类的元信息，另一部分即类变量和常量存储到堆。
> 故而 Java 三大类型变量：基本数据类型变量存储在虚拟机栈局部变量表，类变量和实例变量存储在堆。



**字符串常量池**
```
	JDK 7 之后移动堆中，实现了一个 StringTable 类，它是一个 Hash 表，默认长度为 1009。这个 StringTable 在每个 JVM 实例中只有一份，被所有类共享。字符串常量由一个一个字符组成，放在 StringTable 上。
```



# 类加载全阶段
### 1. 加载
**需要完成的事：**
1. 通过一个类的全限定名来获取定义此类的二进制字节流（类加载器完成）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

### 2. 验证
* 确保 Class 文件的字节流中包含的信息符合规范的全部约束要求

### 3. 准备
* 正式为类中定义的变量（静态变量）分配内存并设置类变量初始值（0）的阶段

### 4. 解析
* 将常量池内的符号引用替换为直接引用
    * 直接引用直接指向目标的指针，相对偏移量，间接定位到目标的句柄
> 并非全部符号引用都在解析时替换为直接引用，这种叫静态解析，另一部分将在每一次运行期间都转化为直接引用，这叫**动态连接**
* 字段解析在本类中未找到时会先找父接口（遍历），再找父类（遍历），方法解析相反，先父类再父接口

### 5. 初始化
初始化阶段就是执行类构造器<clinit>方法的过程
**<clinit>原理**
1. <clinit>() 方法由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
> 说明 static 块执行是在初始化阶段
2. 静态语句块智能访问到定义在静态语句块之前的变量，定义在之后的，静态语句块可以赋值，不能访问（因为类变量已在准备阶段初始化为 0，所以可以赋值）
3. JVM 会保证子类的<clinit>执行前，父类的已执行完毕
4. 父类定义的静态语句块要优先于子类的变量赋值操作
5. 若一个类中没有静态语句块，也没有对变量的赋值操作，则可无<clinit>
6. 接口不能用静态代码块，JVM 自动生成<clinit>且不用先执行父接口的<clinit>，其实现类初始化时也不会执行接口的<clinit>
7. JVM 必须保证一个类的<clinit>在多线程中被正确地加锁同步




# 双亲委派模型
<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/双亲委派模型.48ahpdkibtu0.png" alt="双亲委派模型" width="50%" align=center />

* 若一个类加载器收到类加载请求，会先把请求委派给父类加载器完成，最终传到最顶层的启动类加载器中。只有父加载器无法完成时，子加载器才会自己去加载。（**由下往上，再由上往下**的过程）




# 运行时栈帧结构
* 每个方法对应一个栈帧
* 每个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
* 在编译时栈帧需要分配的内存（局部变量表多大，操作数栈多深）就已确定，写入 Code 属性表
* 方法调用结束后，栈帧也随之销毁

### 1. 局部变量表
1. 以索引定位的方式使用局部变量表
2. 当一个方法被调用时，JVM 会用局部变量表完成参数值到参数变量列表的传递，即实参到形参的传递
3. 若执行实例方法，则局部变量表第 0 位索引的变量槽默认是用于传递所属对象实例的引用，即 this
4. 局部变量表的变量槽可重用
> 为了减少操作数栈和局部变量表过大对资源的浪费，Java虚拟机将局部变量表的变量槽进行重用，当代码执行超出了一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用。
5. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收

### 2. 操作数栈
1. 优化处理：令两个栈帧出现一部分重叠，让下面栈帧部分操作数栈与上面栈帧部分局部变量表重叠在一起，可节约空间，共享部分数据
2. 栈顶缓存技术：将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

### 3. 动态连接
1. 静态解析：常量池的符号引用一部分会在类加载的解析阶段或第一次使用时转为直接引用
2. 动态连接：另一部分将在每一次运行期间都转为直接引用

### 4. 方法返回地址
* 方法返回时需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，主调方法的 PC 值就可以作为返回地址
* 方法正常退出时，栈帧中可能会保存 PC 值，异常退出时返回地址通过异常处理器表确定



**关于静态解析和动态连接的进一步说明**

1. 静态解析成立的前提：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变。即调用目标在程序代码写好，编译器进行编译那一刻就已确定下来
> 符合条件的主要有静态方法和私有方法
2. 分派
* 静态分派（重载）
```java
Human man = new Man()
```
> Human：静态类型
> Man：实际类型
    * 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，最终的静态类型是在编译期可知的。而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道对象的实际类型是什么
    * 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由 JVM 执行的
    * 所以也可理解无法在类加载解析阶段完成转换（实际类型运行期确定）
* 动态分派（重写）
    * 主要调用 invokevirtual （调用所有虚方法）指令，过程如下：
    1. 找到操作数栈顶第一个元素指向的对象的实际类型，记作 C
    2. 若在 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，不通过则报 IllegalAccessError 异常
    3. 否则，按继承关系从下往上依次对父类进行 2 的搜索和验证过程
    4. 若始终找不到，报 AbstractMethodError 异常




# 内存分配与回收策略
### 1. 对象优先在 Eden 分配
* 对象在新生代 Eden 区分配，当 Eden 区没有足够空间进行分配时，JVM 将发起一次 Minor GC

### 2. 大对象直接进入老年代
* 大对象：需要大量连续内存空间的 Java 对象，比如长字符串、大数组

### 3. 长期存活的对象将进入老年代
* JVM 给每个对象定义了一个对象年龄计数器，存储在对象头中。对象通常在 Eden 区诞生，若经过一次 Minor GC 仍存活，且能被 Survivor 容纳，则该对象会移动到 Survivor 空间，年龄设为 1 岁。对象在 Survivor 区每熬过一次 Minor GC，年龄就加 1。当其增加到 **15**（默认值），就会晋升到老年代。

### 4. 动态对象年龄判定
* JVM 并非要求对象年龄一定要达到 15 才能晋升老年代。若**在 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半**，年龄大于或等于该年龄的对象可直接进入老年代

### 5. 空间分配担保
* 由于发生 Minor GC 时，可能有一部分对象进入老年代。最极端的情况就是 Minor GC 时新生代所有对象全部存活，需要老年代进行分配担保
* 主要检查老年代最大可用连续空间是否大于新生代所有对象总空间，若是则本次 Minor GC 安全
* JDK 6 之后只要**老年代连续空间大于新生代对象总大小或历次晋升的平均大小**，就进行 Minor GC，否则 Full GC。




# 新生代分配和转移过程
![新生代分配和转移过程](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/新生代分配和转移过程.6iy67iydsfw0.png)
1. 刚开始时，对象大多申请在 Eden 区，当 Eden 区装满后
2. 对 Eden 区进行 Minor GC，将存活对象复制到 S0，此时 S1 为空
3. 下次 Eden 区满，再执行一次 Minor GC，将消亡的对象清理掉，将存活的对象复制到 S1中，然后清空 Eden；将 S0 中消亡的对象清理，存活的放到 S1（此时 S0 又是空的了）
> Eden 和 S0 是通过同一个 Minor GC 清理的
4. 重复上述过程，当每次对象从 Eden 复制到 S0 或从 S0 复制到 S1，有一个计数器会自动增加值，默认若复制超过 15 次，JVM 会停止复制并将其移到老年代。当老年代对象越来越多，占用空间不够时，就触发 Full GC，进行对象回收。




# 固定可作为 GC Roots 的对象
1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
2. 在方法区中类静态属性引用的对象，如 Java 类的引用类型静态变量
3. 在方法区中常量引用的对象，如字符串常量池里的引用
4. 在本地方法栈中 JNI（Native 方法）引用的对象
5. JVM 内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象以及系统类加载器等
6. 所有被同步锁 Synchronized 持有的对象
7. 反映 JVM 内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等
> 以当前活着的对象为 root，遍历出他们（引用）关联的所有对象，没有遍历到对象即为非存活对象，应当 GC 掉




# 对象死亡过程
1. 若对象在进行可达性分析后发现没有与 GC Roots 相连的引用链，将会第一次被标记，随后进行一次筛选。条件是此对象是否有必要执行 finalize() 方法。若对象没有覆盖 finalize()，或 finalize() 已被调用过，则视为没必要执行
2. 若有必要执行 finalize()，则对象被放置在 F-Queue 队列，稍后由一条由 JVM 自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。随后收集器将对 F-Queue 中的对象进行第二次标记
3. 若两次标记后对象仍未逃脱，则被回收
> 对象逃脱方式
> 只要重新与引用链上的任何一个对象建立关联即可




# 垃圾收集算法
1. 标记-清除算法
* 缺陷：
    * 执行效率不稳定
    * 内存空间的碎片化问题
> 清除：所谓清除并非真的置空，而是把需要清除的对象地址保存在空闲的地址列表中。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放
2. 标记-复制算法
* 对象在内存动态分配中新生代使用该算法
3. 标记-整理算法
* 移动式方法解决了内存碎片问题
* 必须 Stop the world 才能进行



**Stop The World（STW）**

* 指 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都被暂停
* 哪怕 G1 也不能完全避免 STW，只能是随技术提高尽可能地缩短了暂停时间
* STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉
* 开发中不要用 System.gc()，会触发 Full GC，导致 STW



**评估 GC 的性能指标**

1. 吞吐量：运行用户代码的时间占总运行时间的比例
2. 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间（延迟）
3. 内存占用：Java 堆区所占的内存大小



# 经典垃圾收集器
1. Serial（串行回收）
* Serial 收集器采用**标记-复制**算法，串行回收和 Stop the world 机制的方式执行内存回收
2. Serial Old
* Serial 的老年代版本。同样采用串行回收和 Stop the world 机制，但内存回收算法使用的是**标记-整理**算法
3. ParNew（并行回收）
* Serial 的并行版本，支持多线程并行收集
4. Parallel Scavenge（吞吐量优先）
* Parallel Scavenge 收集器基于**标记-复制**算法，能并行收集，目标是提升吞吐量
5. Parallel Old
* Parallel Scavenge 的老年代版本。支持并发收集，基于**标记-整理**算法实现
6. CMS（低延迟）
* 目标：获取最短回收停顿时间
* 步骤：
    1. 初始标记：标记 GC Roots 能直接关联到的对象，需 Stop the world
    2. 并发标记：与用户线程并发执行。从 GC Roots 的直接关联对象开始遍历整个对象图的过程
    3. 重新标记：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
    4. 并发清除：与用户线程并发执行。清理掉标记阶段判断的已经死亡的对象
* 缺点：
    1. CMS 对处理器资源极度敏感，适用于四核以上的处理器
    2. 会产生浮动垃圾
    3. 会产生大量内存碎片，需要进行碎片整理
7. G1（并发 + 并行）
* 目标：在延迟可控的情况下获得尽可能高的吞吐量
* G1 回收器面向服务端应用，针对具有大内存、多处理器的机器
* 设计策略：
    * 把连续的 Java 堆划分为多个大小相等的独立 Region 区，每个 Region 区可根据需要扮演 Eden、Survivor 等
    * Region 中海油 Humongous 区，用来存储大对象，G1认为只要大小超过了**一个 Region 容量一半**即为大对象。对于超过了整个 Humongous 的大对象会被存放在 N 个连续的 Humongous 区
    * G1 会跟踪各个 Region 里垃圾堆积的价值（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，优先回收价值最大的那些 Region
* 步骤：
    1. 初始标记：标记 GC Roots 能直接关联到的对象并修改 TAMS 指针，让下一阶段能正确地在可用 Region 中分配新对象。需 Stop the world
    2. 并发标记：可达性分析，递归扫描整个堆的对象图，与用户线程并发执行
    3. 最终标记：暂停用户线程，用于处理并发阶段结束后仍遗留下来的少量 SATB 记录
    4. 筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本排序，根据用户期望的停顿时间来制定回收计划