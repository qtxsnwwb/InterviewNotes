# 对象创建流程图
<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/对象创建步骤流程图.3sv9496yg7s0.png" alt="对象创建步骤流程图" width="35%" align=center />



# 对象的内存布局
![对象的内存布局](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/对象的内存布局.2ydkr8779ge0.png)



# 对象的访问定位
### 对象的存储分为 3 部分：
1. 堆中存储对象实例数据，以及指向对象类型数据的指针
2. 方法区中存储对象类型数据（类信息：访问权限，类名等）
3. 虚拟机栈的局部变量表中存储对象引用（reference 类型）

### 句柄池访问：
* reference 指向对象的句柄地址（位于堆中），句柄地址包括指向堆中对象实例数据的指针和指向方法区中对象类型数据的指针



# 堆溢出和栈溢出
### 堆溢出
```
	每个方法创建时都会创建一个栈帧，栈溢出就是创建的栈帧超过了栈的深度。最有可能的原因就是方法递归调用产生的
```

### 堆溢出
```
	堆中存储的主要是对象，如果不断地 new 对象，则会导致堆中的空间溢出
```

### 内存泄漏和内存溢出
* 内存泄漏：程序在申请内存后，无法释放已申请的内存空间。内存泄漏堆积的后果是内存溢出
* 内存溢出：程序申请内存时，没有足够的内存供申请者使用

### 内存溢出的原因：
1. 内存中加载的数据量过于庞大，如一次数据库取出过多数据
2. 集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收
3. 代码中存在死循环或循环产生过多重复的对象实体
4. 使用的第三方软件中的 bug
5. 启动参数内存值设定的过小

### 内存溢出的解决方案
1. 修改 JVM 启动参数，直接增加内存
2. 检查错误日志，查看 OutOfMemory 前是否有其他异常或错误
3. 对代码进行走查和分析，找出可能发生内存溢出的位置

> Java 中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还必须拥有一个与原方法不同的特征签名。
> 特征签名指一个方法中各个参数在常量池中的字段符号引用的集合。返回值不属于特征签名，因此 Java 无法仅仅依靠返回值不同来对已有方法重载。



**静态变量（类变量）的初始化与存储**

* 类加载的准备阶段会为类变量分配内存并设置初始值。JDK 8 之后，类变量会随着 Class 对象一起存放在 Java 堆中。设置的初始值为 0。对类变量的赋值是在初始化阶段调用<clinit>完成，非类变量（实例变量）赋值是在初始化阶段调用<init>完成。
* 若 final 修饰了类变量，并且这个变量的数据类型是基本类型或 java.lang.String，则再准备阶段会被初始化为 ConstantValue 指定的值。

> JDK 8 之后取消了永久代，将永久代存储的信息一分为二，一部分为元空间，存储类的元信息，另一部分即类变量和常量存储到堆。
> 故而 Java 三大类型变量：基本数据类型变量存储在虚拟机栈局部变量表，类变量和实例变量存储在堆。



**字符串常量池**
```
	JDK 7 之后移动堆中，实现了一个 StringTable 类，它是一个 Hash 表，默认长度为 1009。这个 StringTable 在每个 JVM 实例中只有一份，被所有类共享。字符串常量由一个一个字符组成，放在 StringTable 上。
```



# 类加载全阶段
### 1. 加载
**需要完成的事：**
1. 通过一个类的全限定名来获取定义此类的二进制字节流（类加载器完成）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

### 2. 验证
* 确保 Class 文件的字节流中包含的信息符合规范的全部约束要求

### 3. 准备
* 正式为类中定义的变量（静态变量）分配内存并设置类变量初始值（0）的阶段

### 4. 解析
* 将常量池内的符号引用替换为直接引用
    * 直接引用直接指向目标的指针，相对偏移量，间接定位到目标的句柄
> 并非全部符号引用都在解析时替换为直接引用，这种叫静态解析，另一部分将在每一次运行期间都转化为直接引用，这叫**动态连接**
* 字段解析在本类中未找到时会先找父接口（遍历），再找父类（遍历），方法解析相反，先父类再父接口

### 5. 初始化
初始化阶段就是执行类构造器<clinit>方法的过程
**<clinit>原理**
1. <clinit>() 方法由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
> 说明 static 块执行是在初始化阶段
2. 静态语句块智能访问到定义在静态语句块之前的变量，定义在之后的，静态语句块可以赋值，不能访问（因为类变量已在准备阶段初始化为 0，所以可以赋值）
3. JVM 会保证子类的<clinit>执行前，父类的已执行完毕
4. 父类定义的静态语句块要优先于子类的变量赋值操作
5. 若一个类中没有静态语句块，也没有对变量的赋值操作，则可无<clinit>
6. 接口不能用静态代码块，JVM 自动生成<clinit>且不用先执行父接口的<clinit>，其实现类初始化时也不会执行接口的<clinit>
7. JVM 必须保证一个类的<clinit>在多线程中被正确地加锁同步




# 双亲委派模型
<img src="https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/双亲委派模型.48ahpdkibtu0.png" alt="双亲委派模型" width="50%" align=center />

* 若一个类加载器收到类加载请求，会先把请求委派给父类加载器完成，最终传到最顶层的启动类加载器中。只有父加载器无法完成时，子加载器才会自己去加载。（**由下往上，再由上往下**的过程）




# 运行时栈帧结构
* 每个方法对应一个栈帧
* 每个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
* 在编译时栈帧需要分配的内存（局部变量表多大，操作数栈多深）就已确定，写入 Code 属性表
* 方法调用结束后，栈帧也随之销毁

### 1. 局部变量表
1. 以索引定位的方式使用局部变量表
2. 当一个方法被调用时，JVM 会用局部变量表完成参数值到参数变量列表的传递，即实参到形参的传递
3. 若执行实例方法，则局部变量表第 0 位索引的变量槽默认是用于传递所属对象实例的引用，即 this
4. 局部变量表的变量槽可重用
> 为了减少操作数栈和局部变量表过大对资源的浪费，Java虚拟机将局部变量表的变量槽进行重用，当代码执行超出了一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用。
5. 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收

### 2. 操作数栈
1. 优化处理：令两个栈帧出现一部分重叠，让下面栈帧部分操作数栈与上面栈帧部分局部变量表重叠在一起，可节约空间，共享部分数据
2. 栈顶缓存技术：将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

### 3. 动态连接
1. 静态解析：常量池的符号引用一部分会在类加载的解析阶段或第一次使用时转为直接引用
2. 动态连接：另一部分将在每一次运行期间都转为直接引用

### 4. 方法返回地址
* 方法返回时需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，主调方法的 PC 值就可以作为返回地址
* 方法正常退出时，栈帧中可能会保存 PC 值，异常退出时返回地址通过异常处理器表确定



**关于静态解析和动态连接的进一步说明**

1. 静态解析成立的前提：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变。即调用目标在程序代码写好，编译器进行编译那一刻就已确定下来
> 符合条件的主要有静态方法和私有方法
2. 分派
* 静态分派（重载）
```java
Human man = new Man()
```
> Human：静态类型
> Man：实际类型
    * 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，最终的静态类型是在编译期可知的。而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道对象的实际类型是什么
    * 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由 JVM 执行的
    * 所以也可理解无法在类加载解析阶段完成转换（实际类型运行期确定）
* 动态分派（重写）
    * 主要调用 invokevirtual （调用所有虚方法）指令，过程如下：
    1. 找到操作数栈顶第一个元素指向的对象的实际类型，记作 C
    2. 若在 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，不通过则报 IllegalAccessError 异常
    3. 否则，按继承关系从下往上依次对父类进行 2 的搜索和验证过程
    4. 若始终找不到，报 AbstractMethodError 异常




# 内存分配与回收策略
### 1. 对象优先在 Eden 分配
* 对象在新生代 Eden 区分配，当 Eden 区没有足够空间进行分配时，JVM 将发起一次 Minor GC

### 2. 大对象直接进入老年代
* 大对象：需要大量连续内存空间的 Java 对象，比如长字符串、大数组

### 3. 长期存活的对象将进入老年代
* JVM 给每个对象定义了一个对象年龄计数器，存储在对象头中。对象通常在 Eden 区诞生，若经过一次 Minor GC 仍存活，且能被 Survivor 容纳，则该对象会移动到 Survivor 空间，年龄设为 1 岁。对象在 Survivor 区每熬过一次 Minor GC，年龄就加 1。当其增加到 **15**（默认值），就会晋升到老年代。

### 4. 动态对象年龄判定
* JVM 并非要求对象年龄一定要达到 15 才能晋升老年代。若**在 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半**，年龄大于或等于该年龄的对象可直接进入老年代

### 5. 空间分配担保
* 由于发生 Minor GC 时，可能有一部分对象进入老年代。最极端的情况就是 Minor GC 时新生代所有对象全部存活，需要老年代进行分配担保
* 主要检查老年代最大可用连续空间是否大于新生代所有对象总空间，若是则本次 Minor GC 安全
* JDK 6 之后只要**老年代连续空间大于新生代对象总大小或历次晋升的平均大小**，就进行 Minor GC，否则 Full GC。




# 新生代分配和转移过程
![新生代分配和转移过程](https://cdn.jsdelivr.net/gh/qtxsnwwb/image-hosting@master/20210823/新生代分配和转移过程.6iy67iydsfw0.png)
1. 刚开始时，对象大多申请在 Eden 区，当 Eden 区装满后
2. 对 Eden 区进行 Minor GC，将存活对象复制到 S0，此时 S1 为空
3. 下次 Eden 区满，再执行一次 Minor GC，将消亡的对象清理掉，将存活的对象复制到 S1中，然后清空 Eden；将 S0 中消亡的对象清理，存活的放到 S1（此时 S0 又是空的了）
> Eden 和 S0 是通过同一个 Minor GC 清理的
4. 重复上述过程，当每次对象从 Eden 复制到 S0 或从 S0 复制到 S1，有一个计数器会自动增加值，默认若复制超过 15 次，JVM 会停止复制并将其移到老年代。当老年代对象越来越多，占用空间不够时，就触发 Full GC，进行对象回收。